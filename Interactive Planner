#include <SFML/Graphics.hpp>
#include <iostream>
#include <map>
#include <vector>
#include <string>
#include <ctime>
#include <sstream>
#include <iomanip>

// Helper function to generate dates for a week based on a given offset
// `weekOffset` determines the week to display (0 for the current week, +1 for next week, etc.)
std::vector<std::string> getWeekDates(int weekOffset) {
    std::vector<std::string> daysWithDates(7); // Vector to store formatted dates for the week

    std::time_t now = std::time(nullptr); // Get the current time
    std::tm currentTime = *std::localtime(&now); // Convert time to a struct with calendar date info

    // Calculate the starting day of the week (Monday as the first day)
    int dayOffset = currentTime.tm_wday == 0 ? -6 : 1 - currentTime.tm_wday;

    // Adjust the current date by the week offset
    currentTime.tm_mday += (weekOffset * 7);
    std::mktime(&currentTime); // Normalize the date struct

    // Generate dates for all seven days of the week
    for (int i = 0; i < 7; ++i) {
        std::tm dayTime = currentTime;
        dayTime.tm_mday += dayOffset + i; // Calculate the specific day's date
        std::mktime(&dayTime); // Normalize the date

        std::ostringstream oss;
        oss << std::put_time(&dayTime, "%b %d"); // Format date as "Month Day"
        daysWithDates[i] = oss.str(); // Store formatted date
    }

    return daysWithDates; // Return vector of dates
}

int main() {
    // Define window dimensions
    const int windowWidth = 850;
    const int windowHeight = 500;

    // Create a window using SFML
    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), "Interactive Weekly Planner");

    // Load and scale the planner background texture
    sf::Texture plannerTexture;
    if (!plannerTexture.loadFromFile("/Users/absfolder/Desktop/planner.jpg")) {
        std::cerr << "Error: Failed to load planner image.\n";
        return -1;
    }
    sf::Sprite plannerSprite;
    plannerSprite.setTexture(plannerTexture);
    sf::Vector2u textureSize = plannerTexture.getSize();
    plannerSprite.setScale(
        static_cast<float>(windowWidth) / textureSize.x,
        static_cast<float>(windowHeight) / textureSize.y
    );

    // Load a font for rendering text
    sf::Font font;
    if (!font.loadFromFile("/System/Library/Fonts/Supplemental/Arial.ttf")) {
        std::cerr << "Error: Failed to load font.\n";
        return -1;
    }

    // Initialize variables for week navigation and task management
    int weekOffset = 0; // Offset to track which week's tasks are displayed
    std::vector<std::string> weekDates = getWeekDates(weekOffset); // Get dates for the current week
    std::map<int, std::vector<std::vector<std::string>>> weekTasks; // Map to store tasks for each week
    weekTasks[weekOffset] = std::vector<std::vector<std::string>>(7); // Initialize tasks for the current week

    // Define text for displaying dates and tasks
    sf::Text dateText, taskText, inputText, generalTaskText;
    dateText.setFont(font);
    dateText.setCharacterSize(15);
    dateText.setFillColor(sf::Color::Black);

    taskText.setFont(font);
    taskText.setCharacterSize(12);
    taskText.setFillColor(sf::Color::Black);

    inputText.setFont(font);
    inputText.setCharacterSize(15);
    inputText.setFillColor(sf::Color::Black);

    generalTaskText.setFont(font);
    generalTaskText.setCharacterSize(12);
    generalTaskText.setFillColor(sf::Color::Black);

    // Define input box for task entry
    sf::RectangleShape inputBox(sf::Vector2f(200.f, 30.f));
    inputBox.setFillColor(sf::Color(200, 200, 200));
    inputBox.setOutlineThickness(2.f);
    inputBox.setOutlineColor(sf::Color::Black);
    inputBox.setPosition(400.f, 30.f);

    // Define positions for date display (aligned with planner image)
    sf::Vector2f positions[] = {
        {380.f, 69.f}, {575.f, 69.f}, {770.f, 69.f},
        {380.f, 267.f}, {575.f, 267.f}, {770.f, 267.f}, {770.f, 365.f}
    };

    // Variables for managing user interaction
    std::string userInput = ""; // Store user-typed input
    int selectedDay = -1; // Track which day's tasks are being edited
    bool generalTaskSelected = false; // Whether the general task area is selected
    std::vector<std::string> generalTasks; // Store general tasks not tied to a specific day

    // General task display settings
    float generalTaskStartX = 50.f;
    float generalTaskStartY = 90.f;
    float generalTaskSpacing = 18.f;

    // Main event loop
    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            // Handle mouse clicks for selecting days or general tasks
            if (event.type == sf::Event::MouseButtonPressed && event.mouseButton.button == sf::Mouse::Left) {
                sf::Vector2i mousePos = sf::Mouse::getPosition(window);

                // Check if general task area is clicked
                if (mousePos.x >= 20.f && mousePos.x <= 200.f && mousePos.y >= 50.f && mousePos.y <= 450.f) {
                    generalTaskSelected = true;
                    selectedDay = -1;
                } else {
                    generalTaskSelected = false;

                    // Check if a specific day is clicked
                    for (int i = 0; i < 7; ++i) {
                        sf::FloatRect boxBounds(positions[i], {150.f, 50.f});
                        if (boxBounds.contains(static_cast<sf::Vector2f>(mousePos))) {
                            selectedDay = i;
                            generalTaskSelected = false;
                        }
                    }
                }
            }

            // Handle text input for adding tasks
            if (event.type == sf::Event::TextEntered) {
                if (event.text.unicode == '\b') { // Handle backspace
                    if (!userInput.empty())
                        userInput.pop_back();
                } else if (event.text.unicode == '\r' || event.text.unicode == '\n') { // Handle Enter key
                    if (generalTaskSelected && !userInput.empty()) {
                        generalTasks.push_back(userInput); // Add to general tasks
                        userInput.clear();
                    } else if (selectedDay != -1 && !userInput.empty()) {
                        weekTasks[weekOffset][selectedDay].push_back(userInput); // Add to day's tasks
                        userInput.clear();
                    }
                } else if (event.text.unicode < 128) { // Add typed character
                    userInput += static_cast<char>(event.text.unicode);
                }
            }

            // Handle keyboard input for week navigation
            if (event.type == sf::Event::KeyPressed) {
                if (event.key.code == sf::Keyboard::Left) {
                    weekOffset--;
                    weekDates = getWeekDates(weekOffset);
                    if (weekTasks.find(weekOffset) == weekTasks.end()) {
                        weekTasks[weekOffset] = std::vector<std::vector<std::string>>(7);
                    }
                } else if (event.key.code == sf::Keyboard::Right) {
                    weekOffset++;
                    weekDates = getWeekDates(weekOffset);
                    if (weekTasks.find(weekOffset) == weekTasks.end()) {
                        weekTasks[weekOffset] = std::vector<std::vector<std::string>>(7);
                    }
                }
            }
        }

        // Update the input text
        inputText.setString(userInput);

        // Render the planner background and tasks
        window.clear();
        window.draw(plannerSprite);

        // Draw general tasks
        float taskY = generalTaskStartY;
        for (const auto &task : generalTasks) {
            generalTaskText.setString(task);
            generalTaskText.setPosition(generalTaskStartX, taskY);
            window.draw(generalTaskText);
            taskY += generalTaskSpacing;
        }

        // Draw dates and tasks for each day
        for (int i = 0; i < 7; ++i) {
            dateText.setString(weekDates[i]);
            dateText.setPosition(positions[i]);
            window.draw(dateText);

            float taskY = positions[i].y + 20.f;
            float taskX = positions[i].x - 140.f;
            for (const auto &task : weekTasks[weekOffset][i]) {
                taskText.setString(task);
                taskText.setPosition(taskX, taskY);
                window.draw(taskText);
                taskY += 15.f;
            }
        }

        // Draw the input box if a task area is selected
        if (selectedDay != -1 || generalTaskSelected) {
            window.draw(inputBox);
            window.draw(inputText);
        }

        window.display();
    }

    return 0;
}
